package com.jervisffb.net.handlers

import com.jervisffb.engine.actions.Revert
import com.jervisffb.engine.utils.InvalidActionException
import com.jervisffb.net.GameSession
import com.jervisffb.net.JervisExitCode
import com.jervisffb.net.JervisNetworkWebSocketConnection
import com.jervisffb.net.messages.GameActionMessage
import com.jervisffb.net.messages.InvalidGameActionOwnerServerError
import com.jervisffb.net.messages.InvalidGameActionTypeServerError
import com.jervisffb.net.messages.OutOfOrderGameActionServerError
import com.jervisffb.net.messages.UnknownServerError

/**
 * Server handler for game actions sent by clients.
 *
 * @see GameActionMessage
 * @see InternalGameActionMessageHandler
 */
class GameActionHandler(override val session: GameSession) : ClientMessageHandler<GameActionMessage>() {

    override suspend fun handleMessage(message: GameActionMessage, connection: JervisNetworkWebSocketConnection?) {
        val game = session.game
        val client = connection?.let { session.getPlayerClient(it) } ?: error("Connection required for game actions")

        // Check that the game has really started
        if (game == null) {
            session.out.sendError(
                connection,
                OutOfOrderGameActionServerError(message.clientIndex,"Game is not initialized yet. Please wait for the GameStarted event to be sent.")
            )
            return
        }

        // We should never handle `Revert` actions on the server, since it should be impossible
        // to get the server in an illegal state. These actions should only ever be created locally
        // on a client as a response to a server error code.
        if (message.action is Revert) {
            client.trackErrorSent()
            val error = InvalidGameActionTypeServerError(
                game.currentActionIndex() + 1,
                "Clients are not allowed to send `Revert` to the server"
            )
            session.out.sendError(connection, error)
            return
        }

        // Check if the connection was allowed to generate the action. If the connection is `null` it meant
        // the message was sent by server itself. If the action isn't allowed to be generated by the connection
        // an error is sent back that allows it to roll back.
        val actionSender = session.getPlayerClient(connection)?.team?.id!!
        val expectedActionOwner = session.game?.getAvailableActions()?.team?.id

        if (expectedActionOwner != null && actionSender != expectedActionOwner) {
            session.out.sendError(
                connection,
                InvalidGameActionOwnerServerError(
                    message.clientIndex,
                    "The server is currently waiting for an action by the other coach. Server state: ${session.game?.currentNode()}. Ignoring message with id: ${message.clientIndex}."
                )
            )
            return
        }

        try {
            val expectedDeltaId = session.game!!.currentActionIndex() + 1
            if (message.clientIndex != expectedDeltaId) {
                session.out.sendError(
                    connection,
                    OutOfOrderGameActionServerError(message.clientIndex,"Expected $expectedDeltaId, but received ${message.clientIndex}.")
                )
                return
            }
            // The action is finally considered, valid, so we can stop the timer
            val coach = game.getAvailableActions().team.coach
            handleAction(session, client, game, coach.id, message.action, connection)
        } catch (ex: InvalidActionException) {
            val errorMessage = "Server state: [currentNode=${game.currentNode()}, actionIndex=${message.clientIndex}\n${ex.stackTraceToString()}"
            session.out.sendError(
                connection,
                InvalidGameActionTypeServerError(message.clientIndex, errorMessage),
            )
            client.trackErrorSent()
        } catch (ex: Exception) {
            session.out.sendError(
                connection,
                UnknownServerError(ex.stackTraceToString())
            )
            client.trackErrorSent()
        } finally {
            if (client.errorLimitReached()) {
                client.disconnect(JervisExitCode.ERROR_LIMIT_REACHED, "Too many Game Action errors was reported in succession. Terminating the connection.")
            }
        }
    }
}
