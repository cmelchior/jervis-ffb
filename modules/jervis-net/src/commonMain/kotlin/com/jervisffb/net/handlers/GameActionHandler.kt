package com.jervisffb.net.handlers

import com.jervisffb.engine.GameEngineController
import com.jervisffb.engine.actions.GameAction
import com.jervisffb.engine.actions.Revert
import com.jervisffb.engine.model.CoachId
import com.jervisffb.engine.utils.InvalidActionException
import com.jervisffb.engine.utils.containsActionWithRandomBehavior
import com.jervisffb.engine.utils.createRandomAction
import com.jervisffb.net.GameSession
import com.jervisffb.net.JervisNetworkWebSocketConnection
import com.jervisffb.net.messages.GameActionMessage
import com.jervisffb.net.messages.InternalGameActionMessage
import com.jervisffb.net.messages.InvalidGameActionOwnerServerError
import com.jervisffb.net.messages.InvalidGameActionTypeServerError
import com.jervisffb.net.messages.OutOfOrderGameActionServerError
import com.jervisffb.net.messages.UnknownServerError
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.datetime.Clock

class GameActionHandler(override val session: GameSession) : ClientMessageHandler<GameActionMessage>() {

    var timeout: Pair<Int, Job>? = null

    override suspend fun handleMessage(message: GameActionMessage, connection: JervisNetworkWebSocketConnection?) {
        val game = session.game

        // Check that the game has really started
        if (game == null) {
            session.out.sendError(
                connection,
                OutOfOrderGameActionServerError(message.clientIndex,"Game is not initialized yet. Please wait for the GameStarted event to be sent.")
            )
            return
        }

        // We should never handle `Revert` actions on the server, since it should be impossible
        // to get the server in an illegal state. These actions should only ever be created locally
        // on the client as a response to a server error code.
        if (message.action is Revert) {
            if (connection != null) {
                val error = InvalidGameActionTypeServerError(
                    game.currentActionIndex() + 1,
                    "Clients are not allowed to send `Revert` to the server"
                )
                session.out.sendError(connection, error)
            }
            return
        }

        // Check if the connection was allowed to generate the action. If the connection is `null` it meant
        // the message was sent by server itself. If the action isn't allowed to be generated by the connection
        // an error is sent back that allows it to roll back.
        if (connection != null) {
            val actionSender = session.getPlayerClient(connection)?.team?.id!!
            val expectedActionOwner = session.game?.getAvailableActions()?.team?.id

            if (expectedActionOwner != null && actionSender != expectedActionOwner) {
                session.out.sendError(
                    connection,
                    InvalidGameActionOwnerServerError(
                        message.clientIndex,
                        "The server is currently waiting for an action by the other coach. Ignoring message with id: ${message.clientIndex}."
                    )
                )
                return
            }
        }

        try {
            val expectedDeltaId = session.game!!.currentActionIndex() + 1
            if (message.clientIndex != expectedDeltaId) {
                session.out.sendError(
                    connection,
                    OutOfOrderGameActionServerError(message.clientIndex,"Expected $expectedDeltaId, but received ${message.clientIndex}.")
                )
                return
            }
            val coach = game.getAvailableActions().team?.coach ?: game.state.homeTeam.coach
            handleAction(session, game, coach.id, message.action, connection)
        } catch (ex: InvalidActionException) {
            session.out.sendError(
                connection,
                InvalidGameActionTypeServerError(message.clientIndex, ex.stackTraceToString()),
            )
        } catch (ex: Exception) {
            session.out.sendError(
                connection,
                UnknownServerError(ex.stackTraceToString())
            )
        }
    }
}

suspend fun handleAction(
    session: GameSession,
    game: GameEngineController,
    producer: CoachId,
    nextAction: GameAction,
    connection: JervisNetworkWebSocketConnection?
) {
    game.handleAction(nextAction)
    val sender = if (connection != null) session.getPlayerClient(connection) else null
    session.out.sendGameActionSync(sender = sender, producer, game.currentActionIndex(), action = nextAction)

    // TODO If start of turn, start the end-of-turn tracker

    // TODO If non-active teams turn, start wait-for-action tracker.

    // TODO How to handle if end-of-turn tracker triggers when waiting

    // If the Game is set up so the server handles all random actions, we should now roll forward creating them here.
    var availableActions = game.getAvailableActions()
    while (!session.gameSettings.clientSelectedDiceRolls && availableActions.containsActionWithRandomBehavior()) {
        val action = createRandomAction(game.state, availableActions)
        game.handleAction(action)
        // If no producer, we just set it to the Home Team
        val producer = session.coaches.firstOrNull { it.coach == availableActions.team?.coach } ?: session.coaches.first()
        session.out.sendGameActionSync(sender = null, producer.coach.id, game.currentActionIndex(), action = action)
        availableActions = game.getAvailableActions()
    }

    // Last, before waiting for the next action, we set up any server timeouts
    // TODO Figure out exactly which timer to use
    if (session.gameSettings.timerSettings.timersEnabled) {
        val nextIndex = game.currentActionIndex() + 1
        session.scope.launch {
            // delay(session.gameSettings.timerSettings.turnLimitSeconds)
            session.sendInternalMessage(connection, InternalGameActionMessage(nextIndex))
        }
    }
}

suspend fun rollForwardToUserAction(session: GameSession, game: GameEngineController, connection: JervisNetworkWebSocketConnection) {
    var availableActions = game.getAvailableActions()
    while (availableActions.containsActionWithRandomBehavior()) {
        val action = createRandomAction(game.state, availableActions)
        game.handleAction(action)
        // If no producer, we just set it to the Home Team
        val producer = session.coaches.firstOrNull { it.coach == availableActions.team?.coach } ?: session.coaches.first()
        session.out.sendGameActionSync(sender = null, producer.coach.id,session.game?.currentActionIndex()!!, action = action)
        availableActions = game.getAvailableActions()
    }

    // Last, before waiting for the next action, we set up any server timeouts
    // TODO Figure out exactly which timer to use
    if (session.gameSettings.timerSettings.timersEnabled) {
        val nextIndex = game.currentActionIndex() + 1
        session.scope.launch {
            // delay(session.gameSettings.timerSettings.turnLimitSeconds)
            println("TIMER: ${Clock.System.now()}.")
            // TODO Figure out how to select automated actions
            session.sendInternalMessage(connection, InternalGameActionMessage(nextIndex))
        }
    }
}

