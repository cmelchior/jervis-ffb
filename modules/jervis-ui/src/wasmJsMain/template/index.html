<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jervis Fantasy Football</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <meta name="description" content="(Under Development) Jervis Fantasy Football is a free client for playing Blood Bowl, both standalone and online. It aims to be compatible with FUMBBL.">
    <meta name="keywords" content="blood bowl, fantasy football, jervis, blood, bowl, ffb, fumbbl, play, online, standalone, bb2020" >
    <meta name="author" content="Christian Melchior ">
    <link type="text/css" rel="stylesheet" href="styles.css">
    <script>
        // Work-around for Kotlin WASM not allowing dynamic js() functions.
        function playSound(filePath) {
            console.log("Playing: " + filePath);
            new Audio(filePath).play();
        }
    </script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #C60000;
            font-family: sans-serif;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #progressBar {
            width: 300px;
            display: flex;
            flex-direction: column;
        }
        #progressBackground {
            width: 100%;
            height: 5px;
            background-color: #FFBE2655;
            position: relative;
            overflow: hidden;
        }
        #progressFill {
            height: 100%;
            width: 0%;
            background-color: #FFBE26;
            transition: width 0.2s ease;
        }
        .status {
            display: flex;
            justify-content: space-between;
            width: 100%;
            line-height: 1em;
            margin-top: 0.5rem;
            font-size: 1rem;
            font-weight: normal;
            color: #FFBE26;
        }
    </style>
</head>
<body>
    <div id="container">
        <img src="logo.svg" width="300px">
        <div id="progressBar">
            <div id="progressBackground">
                <div id="progressFill"></div>
            </div>
            <div class="status">
                <span id="statusDescription">Left-aligned text</span>
                <span id="statusValue">Right-aligned text</span>
            </div>
        </div>
    </div>
    <script>
        const url = `%composeAppRef%`;
        const progressFill = document.getElementById("progressFill");
        const statusDescription = document.getElementById("statusDescription");
        const statusValue = document.getElementById("statusValue");
        statusDescription.textContent = 'Loading';
        statusValue.textContent = '0%';

        function updateProgress(percent) {
            progressFill.style.width = `${percent}%`;
            statusValue.textContent = `${percent}%`;
        }

        function showError(err) {
            console.log(JSON.stringify(err));
            statusValue.textContent = "";
            if (err.message !== undefined && err.message !== '') {
                statusDescription.textContent = `Error loading app: ${err.message}`;
            } else {
                statusDescription.textContent = `Error loading app`;
            }
        }

        fetch(url)
            .then(async (response) => {
                if (!response.ok) {
                    statusDescription.textContent = `Error loading app (${response.status}): ${response.statusText}`;
                    statusValue.textContent = ""
                }
                const contentLength = response.headers.get("Content-Length");
                const reader = response.body.getReader();
                let received = 0;
                let simulatedProgress = 0;
                let simInterval = null;

                // If there is no content-length, we just fake it up until 95%
                if (!contentLength) {
                    simInterval = setInterval(() => {
                        simulatedProgress = Math.min(simulatedProgress + Math.random() * 5, 95);
                        updateProgress(simulatedProgress);
                    }, 100);
                }

                // Load the app
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    received += value.length;
                    if (contentLength) {
                        updateProgress((received / contentLength) * 100);
                    }
                }

                // App is done loading, prepare to open it. It can also take a little while, not 100%
                // sure why. I am guessing unpacking resources, but it needs to be investigated.
                if (simInterval) clearInterval(simInterval);
                updateProgress(100);
                let dots = 0;
                statusDescription.textContent = 'Opening App';
                const openingAnimation = setInterval(() => {
                    dots = (dots + 1) % 4;
                    statusDescription.textContent = 'Opening App' + '.'.repeat(dots);
                }, 500);
                statusValue.textContent = "";

                // If WebAssembly fails to compile, it is most likely because there is a mismatch
                // between caches and the server. We try to avoid this, but just in case, show a
                // slightly better error message (rather than having the page fail silently).
                window.addEventListener("error", (event) => {
                    if (event.message.includes("WebAssembly") || event.message.includes("compile")) {
                        clearInterval(openingAnimation);
                        statusDescription.textContent = "New version detected. Please refresh the page.";
                    }
                });

                // Now, load the app using <script> so relative URLs work. This is required as Compose
                // also reference other wasm files using relative urls.
                const script = document.createElement("script");
                script.src = url;
                script.onerror = (err) => {
                    clearInterval(openingAnimation);
                    showError(err);
                }
                document.body.appendChild(script);
            })
            .catch((err) => {
                showError(err);
            });
    </script>
</body>
</html>