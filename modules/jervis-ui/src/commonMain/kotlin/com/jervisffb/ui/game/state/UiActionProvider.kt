package com.jervisffb.ui.game.state

import com.jervisffb.engine.ActionRequest
import com.jervisffb.engine.GameEngineController
import com.jervisffb.engine.actions.GameAction
import com.jervisffb.engine.actions.GameActionId
import com.jervisffb.engine.model.Team
import com.jervisffb.ui.game.UiGameSnapshot
import com.jervisffb.ui.game.UiSnapshotTimerData
import com.jervisffb.utils.singleThreadDispatcher
import kotlinx.coroutines.CoroutineExceptionHandler
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.channels.BufferOverflow
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.MutableSharedFlow

/**
 * Wrapper class for user or system generated [GameAction]s. It also
 * contains a reference to what the id it expect to be executed at. This allows
 * us to catch race conditions where events are generated by multiple threads
 * or arrive out of order by accident.
 */
data class GeneratedAction(val id: GameActionId, val action: GameAction)

typealias QueuedActionsGenerator = (GameEngineController) -> QueuedActions?
data class QueuedActions(val actions: List<GameAction>, val delayBetweenActions: Boolean = false) {
    constructor(action: GameAction, delayEvent: Boolean = false): this(listOf(action), delayEvent)
}

/**
 * Action Providers are responsible for feeding game actions to the main game loop.
 * This can either be done automatically, through events sent from the server or through
 * the UI.
 */
abstract class UiActionProvider {

    /**
     * @param uiTimerData Used by [com.jervisffb.ui.game.UiGameController] to set a reference
     * to the flow exposing timer data It is up to the action provider how (or if) they want to use it.
     */
    abstract fun startHandler(uiTimerData: MutableSharedFlow<UiSnapshotTimerData>)
    abstract fun actionHandled(team: Team?, action: GameAction)

    val errorHandler = CoroutineExceptionHandler { _, exception ->
        // TODO This doesn't seem to work?
        exception.printStackTrace()
    }

    // Must be single threaded so we can guarantee the order of events in it.
    protected val actionScope = CoroutineScope(
        CoroutineName("ActionSelectorScope")
            + singleThreadDispatcher("ActionScope@${this::hashCode}")
            + errorHandler
    )

    // Used to communicate internally in the ActionProvider. Needed so we can decouple the lifecycle of things.
    // Like the lifecycle of the GameLoop vs. the lifecycle of UI actions.
    protected val actionRequestChannel = Channel<Pair<GameEngineController, ActionRequest>>(capacity = Channel.Factory.RENDEZVOUS, onBufferOverflow = BufferOverflow.SUSPEND)
    protected val actionSelectedChannel = Channel<GeneratedAction>(capacity = Int.MAX_VALUE, onBufferOverflow = BufferOverflow.SUSPEND)

    abstract suspend fun prepareForNextAction(controller: GameEngineController, actions: ActionRequest)

    // Modify the UI, preparing it for selecting the use action
    // If automated steps was prepared in `prepareForNextAction`, this step
    // might do nothing.
    abstract fun decorateAvailableActions(state: UiGameSnapshot, actions: ActionRequest)

    // Wait until the user selects the selected action
    // `id` is the expected id of the action
    abstract suspend fun getAction(id: GameActionId): GeneratedAction

    // Modify the UI to show the selected action (if applicable)
    abstract fun decorateSelectedAction(state: UiGameSnapshot, action: GameAction)

    // User generated an action
    // `id` is the id of the action.
    abstract fun userActionSelected(id: GameActionId, action: GameAction)
    // User generated multiple actions
    // `id` is the id of the first action. The rest will be assigned subsequent id's.
    abstract fun userMultipleActionsSelected(startingId: GameActionId, actions: List<GameAction>, delayEvent: Boolean = true)
    // Queued ActionGenerators are responsible for generating their own GameActionId's since we do not
    // know when they activate. They will not be calculated until next frame. So this function is usually
    // used in combination with `userActionSelected`, which will trigger the sequence
    abstract fun registerQueuedActionGenerator(generator: QueuedActionsGenerator)
    abstract fun hasQueuedActions(): Boolean
    // Remove any queued actions. All actions sent to `actionSelectedChannel` are still there.
    // This method should be called in case of a timeout, making sure that any queued up
    // actions are not triggered, since they are now invalid.
    abstract fun clearQueuedActions()
    // Called when the Game is being shut down. This makes it possible for action providers, to release
    // any associated resources.
    open fun onDispose() {
        // Do nothing
    }
}
