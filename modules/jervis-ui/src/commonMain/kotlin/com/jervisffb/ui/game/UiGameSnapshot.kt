package com.jervisffb.ui.game

import com.jervisffb.engine.ActionRequest
import com.jervisffb.engine.OutOfTimeBehaviour
import com.jervisffb.engine.actions.GameAction
import com.jervisffb.engine.actions.GameActionId
import com.jervisffb.engine.fsm.ProcedureStack
import com.jervisffb.engine.model.FieldSquare
import com.jervisffb.engine.model.Game
import com.jervisffb.engine.model.PlayerId
import com.jervisffb.engine.model.TeamId
import com.jervisffb.engine.model.locations.FieldCoordinate
import com.jervisffb.engine.rules.common.pathfinder.PathFinder
import com.jervisffb.ui.game.dialogs.UserInputDialog
import com.jervisffb.ui.game.model.UiFieldSquare
import com.jervisffb.ui.game.viewmodel.ButtonData
import kotlinx.datetime.Instant

/**
 * Class wrapping timer details for the current game "frame".
 * This is a separate class from [UiGameSnapshot] because timer
 * information is decoupled from actions, and in a server scenario
 * the timer information is arriving in its own message.
 */
data class UiSnapshotTimerData(
    val actionIndex: GameActionId,
    val actionTeam: TeamId,
    val deadline: Instant?,
    val behavior: OutOfTimeBehaviour,
    // If `true`, the coach still has some control over which actions are being selected.
    val userActionAvailable: Boolean,
//    //If set, this is how much time is left to generate the next action
//    val actionLimit: Duration?,
//    // If set, this is how much time is left for the current turn
//    val turnTimer: Duration?,
)

/**
 * Class representing a snapshot of the current UI State as it should be shown for this "frame".
 * Where "frame" is defined as time from an action request to the action being handled.
 *
 * The snapshot should only include the model rules state, and not ephemeral UI state like hover
 * state while selecting the action. These things should be tracked by individual view models.
 *
 * Note, the snapshot is not stable as it references mutable classes. It is only stable
 * for the duration of a single game loop.
 */
class UiGameSnapshot(
    val game: Game,
    val stack: ProcedureStack,
    var actionsRequest: ActionRequest,
    val fieldSquares: MutableMap<FieldCoordinate, UiFieldSquare>,
) {
    // Expected id of the action generated by this snapshot
    val nextActionId = actionsRequest.nextActionId

    fun clearHoverData() {
        // Clear the hover data, only update squares that actually changed
        fieldSquares.entries.forEach { fieldSquare ->
            val square: UiFieldSquare = fieldSquare.value
            if (square.futureMoveValue != null) {
                square.apply {
                    futureMoveValue = null
                    hoverAction = null
                }
            }
        }
    }

    // Actions associated with the Team, and not a particular player
    // These gets rendered under the sidebar for each team
    val homeTeamActions = mutableListOf<ButtonData>()
    val awayTeamActions = mutableListOf<ButtonData>()

    // Attach actions to players found in the dogout
    val dogoutActions: MutableMap<PlayerId, () -> Unit> = mutableMapOf()

    // If set, it means we are in the middle of a move action that allows the player
    // to move multiple squares.
    var pathFinder: PathFinder.AllPathsResult? = null

    // If set, a dialog should be shown as a first priority
    var dialogInput: UserInputDialog? = null
    val unknownActions: MutableList<GameAction> = mutableListOf()

    init {
        fieldSquares[FieldCoordinate.UNKNOWN] = UiFieldSquare(FieldSquare(-1, -1))
    }
}
